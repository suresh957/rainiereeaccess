{"remainingRequest":"F:\\NEW HRMS\\eeaccess\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!F:\\NEW HRMS\\eeaccess\\node_modules\\rxjs\\_esm5\\operator\\retry.js","dependencies":[{"path":"F:\\NEW HRMS\\eeaccess\\node_modules\\rxjs\\_esm5\\operator\\retry.js","mtime":1530166714481},{"path":"F:\\NEW HRMS\\eeaccess\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1530166696506},{"path":"F:\\NEW HRMS\\eeaccess\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1530166690249}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START .._operators_retry PURE_IMPORTS_END */\r\nimport { retry as higherOrder } from '../operators/retry';\r\n/**\r\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\r\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\r\n * as a number parameter) rather than propagating the `error` call.\r\n *\r\n * <img src=\"./img/retry.png\" width=\"100%\">\r\n *\r\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\r\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\r\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\r\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\r\n * @param {number} count - Number of retry attempts before failing.\r\n * @return {Observable} The source Observable modified with the retry logic.\r\n * @method retry\r\n * @owner Observable\r\n */\r\nexport function retry(count) {\r\n    if (count === void 0) {\r\n        count = -1;\r\n    }\r\n    return higherOrder(count)(this);\r\n}\r\n//# sourceMappingURL=retry.js.map\r\n",null]}